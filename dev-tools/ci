#!/bin/bash
# This script is used as a single command to run the x-pack-kibana tests.
#
# It will also attempt to install the appropriate version of node.js
# for the Kibana plugin tests using nvm. Set a custom nvm directory using the
# `NVM_DIR` environment variable.
#

# Turn on semi-strict mode
set -e
set -o pipefail

SCRIPT="$0"

# SCRIPT may be an arbitrarily deep series of symlinks. Loop until we have the concrete path.
while [ -h "$SCRIPT" ] ; do
  ls=$(ls -ld "$SCRIPT")
  # Drop everything prior to ->
  link=$(expr "$ls" : '.*-> \(.*\)$')
  if expr "$link" : '/.*' > /dev/null; then
    SCRIPT="$link"
  else
    SCRIPT=$(dirname "$SCRIPT")/"$link"
  fi
done

# determine base directory
BASE_DIR=$(dirname "$SCRIPT")/..

# make BASE_DIR absolute
BASE_DIR=$(cd "$BASE_DIR"; pwd)

PARENT_DIR=$(cd "$BASE_DIR"/..; pwd)
KIBANA_DIR="${PARENT_DIR}/kibana"

# go to the parent directory
cd $PARENT_DIR

function checkout_sibling {
  project=$1
  targetDir=$2
  useExistingParamName=$3
  useExisting="$(eval "echo "\$$useExistingParamName"")"

  if [ -z ${useExisting:+x} ]; then
    if [ -d "$targetDir" ]; then
      echo "I expected a clean workspace but an '${project}' sibling directory already exists in [$PARENT_DIR]!"
      echo
      echo "Either define '${useExistingParamName}' or remove the existing '${project}' sibling."
      exit 1
    fi

    # read by clone_target_is_valid, and checkout_clone_target populated by pick_clone_target
    cloneAuthor=""
    cloneBranch=""

    function clone_target_is_valid {
      echo " -> checking for '${cloneBranch}' branch at ${cloneAuthor}/${project}"
      if [[ -n "$(git ls-remote --heads git@github.com:${cloneAuthor}/${project}.git ${cloneBranch} 2>/dev/null)" ]]; then
        return 0
      else
        return 1
      fi
    }

    function pick_clone_target {
      echo "picking which branch of ${project} to clone:"

      if [[ -n "$PR_AUTHOR" && -n "$PR_SOURCE_BRANCH" ]]; then
        cloneAuthor="$PR_AUTHOR"
        cloneBranch="$PR_SOURCE_BRANCH"
        if clone_target_is_valid ; then
          return 0
        fi
      fi

      cloneAuthor="elastic"
      cloneBranch="${PR_SOURCE_BRANCH:-${GIT_BRANCH#*/}}" # GIT_BRANCH starts with the repo, i.e., origin/master
      cloneBranch="${cloneBranch:-master}" # fall back to CI branch if not testing a PR
      if clone_target_is_valid ; then
        return 0
      fi

      cloneBranch="$PR_TARGET_BRANCH"
      return 0
    }

    function checkout_clone_target {
      pick_clone_target

      echo " -> checking out '${cloneBranch}' branch from ${cloneAuthor}/${project}..."
      git clone -b "$cloneBranch" "git@github.com:${cloneAuthor}/${project}.git" "$targetDir" --depth=1
      echo " -> checked out ${project} revision: $(git -C ${targetDir} rev-parse HEAD)"
      echo
    }

    checkout_clone_target
  else
    if [ -d "$targetDir" ]; then
      echo "Using existing '${project}' checkout"
    else
      echo "You have defined '${useExistingParamName}' but no existing ${targetDir} directory exists!"
      exit 2
    fi
  fi
}

checkout_sibling "elasticsearch" "${PARENT_DIR}/elasticsearch" "USE_EXISTING_ES"
checkout_sibling "kibana" "$KIBANA_DIR" "USE_EXISTING_KIBANA"
checkout_sibling "x-pack-elasticsearch" "${PARENT_DIR}/elasticsearch-extra/x-pack-elasticsearch" "USE_EXISTING_XPACK"

# back to base directory
cd "$BASE_DIR"

# run kibana's ci setup script in kibana repo
export CACHE_DIR="${PARENT_DIR}/.cache"
source "${KIBANA_DIR}/src/dev/ci_setup/setup.sh"

cd "$KIBANA_DIR"
# install kibana deps
yarn --frozen-lockfile
cd -

# output the commands
set -xuf

# clean
gradle --stacktrace clean

# Actually run the tests
gradle check

# Confirm that building the project works
gradle assemble

# ~*~ shell-script-mode ~*~
