#!/bin/bash
# This script is used as a single command to run the x-pack-kibana tests.
#
# It will also attempt to install the appropriate version of node.js
# for the Kibana plugin tests using nvm. Set a custom nvm directory using the
# `NVM_DIR` environment variable.
#

# Turn on semi-strict mode
set -e
set -o pipefail

SCRIPT="$0"

# SCRIPT may be an arbitrarily deep series of symlinks. Loop until we have the concrete path.
while [ -h "$SCRIPT" ] ; do
  ls=$(ls -ld "$SCRIPT")
  # Drop everything prior to ->
  link=$(expr "$ls" : '.*-> \(.*\)$')
  if expr "$link" : '/.*' > /dev/null; then
    SCRIPT="$link"
  else
    SCRIPT=$(dirname "$SCRIPT")/"$link"
  fi
done

# determine base directory
BASE_DIR=$(dirname "$SCRIPT")/..

# make BASE_DIR absolute
BASE_DIR=$(cd "$BASE_DIR"; pwd)

PARENT_DIR=$(cd "$BASE_DIR"/..; pwd)

# go to the parent directory
cd $PARENT_DIR

function checkout_sibling {
  project=$1
  targetDir=$2
  useExistingParamName=$3
  useExisting="$(eval "echo "\$$useExistingParamName"")"

  if [ -z ${useExisting:+x} ]; then
    if [ -d "$targetDir" ]; then
      echo "I expected a clean workspace but an '${project}' sibling directory already exists in [$PARENT_DIR]!"
      echo
      echo "Either define '${useExistingParamName}' or remove the existing '${project}' sibling."
      exit 1
    fi

    # read by clone_target_is_valid, and checkout_clone_target populated by pick_clone_target
    cloneAuthor=""
    cloneBranch=""

    function clone_target_is_valid {
      echo " -> checking for '${cloneBranch}' branch at ${cloneAuthor}/${project}"
      if [[ -n "$(git ls-remote --heads git@github.com:${cloneAuthor}/${project}.git ${cloneBranch} 2>/dev/null)" ]]; then
        return 0
      else
        return 1
      fi
    }

    function pick_clone_target {
      echo "picking which branch of ${project} to clone:"

      if [[ -n "$PR_AUTHOR" && -n "$PR_SOURCE_BRANCH" ]]; then
        cloneAuthor="$PR_AUTHOR"
        cloneBranch="$PR_SOURCE_BRANCH"
        if clone_target_is_valid ; then
          return 0
        fi
      fi

      cloneAuthor="elastic"
      cloneBranch="${PR_SOURCE_BRANCH:-${GIT_BRANCH#*/}}" # GIT_BRANCH starts with the repo, i.e., origin/master
      cloneBranch="${cloneBranch:-master}" # fall back to CI branch if not testing a PR
      if clone_target_is_valid ; then
        return 0
      fi

      cloneBranch="$PR_TARGET_BRANCH"
      return 0
    }

    function checkout_clone_target {
      pick_clone_target

      echo " -> checking out '${cloneBranch}' branch from ${cloneAuthor}/${project}..."

      case "${cloneAuthor}/${project}#${cloneBranch}" in
        "elastic/elasticsearch#master")
          echo " -> HOTFIX: rewriting checkout to 83522ab4e56a1e46351dff4970f5e08e43ada6f4 because of temporary incompatibility with master"
          checkout_clone_target_commit 83522ab4e56a1e46351dff4970f5e08e43ada6f4
          ;;

        "elastic/x-pack-elasticsearch#master")
          echo " -> HOTFIX: rewriting checkout to 90913f485b070ada9f22ba4ec46c81b20c8ffb7e because of temporary incompatibility with master"
          checkout_clone_target_commit 90913f485b070ada9f22ba4ec46c81b20c8ffb7e
          ;;

        *)
          git clone -b "$cloneBranch" "git@github.com:${cloneAuthor}/${project}.git" "$targetDir" --depth=1
          echo " -> checked out ${project} revision: $(git -C ${targetDir} rev-parse HEAD)"
          echo
          ;;
      esac
    }

    function checkout_clone_target_commit {
      sha="$1"

      mkdir -p "$targetDir"
      cd "$targetDir"
      git init
      git remote add origin "git@github.com:${cloneAuthor}/${project}.git"
      git fetch origin "${cloneBranch}"
      git reset --hard "$sha"
      cd -

      echo " -> checked out ${project} revision: $(git -C ${targetDir} rev-parse HEAD)"
      echo
    }

    checkout_clone_target
  else
    if [ -d "$targetDir" ]; then
      echo "Using existing '${project}' checkout"
    else
      echo "You have defined '${useExistingParamName}' but no existing ${targetDir} directory exists!"
      exit 2
    fi
  fi
}

checkout_sibling "elasticsearch" "${PARENT_DIR}/elasticsearch" "USE_EXISTING_ES"
checkout_sibling "kibana" "${PARENT_DIR}/kibana" "USE_EXISTING_KIBANA"
checkout_sibling "x-pack-elasticsearch" "${PARENT_DIR}/elasticsearch-extra/x-pack-elasticsearch" "USE_EXISTING_XPACK"

# back to base directory
cd "$BASE_DIR"

# install the correct node.js version
if [ -z ${NVM_DIR:+x} ]; then
  export NVM_DIR="/var/lib/jenkins/.nvm";
fi

NVM_SCRIPT="$NVM_DIR/nvm.sh"
if [ -s "$NVM_SCRIPT" ]; then
  . "$NVM_SCRIPT"  # load nvm
else
  echo "Unable to find the nvm script at \"$NVM_SCRIPT\""
  exit 1
fi

echo "Installing node.js version $(cat .node-version)..."
nvm install "$(cat .node-version)"

echo "Installing kibana dependencies"
cd "../kibana"
npm prune
npm install
cd -

echo "Running x-pack-kibana tests..."
echo "Running in $PWD"

# output the commands
set -xuf

# clean
gradle --stacktrace clean

# Actually run the tests
gradle check

# Confirm that building the project works
gradle assemble

# ~*~ shell-script-mode ~*~
